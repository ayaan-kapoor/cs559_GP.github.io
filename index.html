<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Primal Strike Prototype - Final Build</title>
<style>
    body { margin: 0; overflow: hidden; background-color: #333; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #group-id { position: absolute; top: 10px; left: 10px; color: white; font-size: 24px; z-index: 10; }
    
    /* HP Bar Styling */
    #hp-bar-container {
        position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
        width: 300px; height: 30px; background: rgba(0,0,0,0.5);
        border: 2px solid white; border-radius: 5px; z-index: 50; display: none;
    }
    #hp-bar-fill { width: 100%; height: 100%; background: #28a745; transition: width 0.2s; }
    #hp-text { position: absolute; width: 100%; text-align: center; color: white; font-weight: bold; line-height: 30px; }

    /* Main Menu Styling */
    #main-menu {
        position: absolute; width: 100%; height: 100%; background: #111;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        z-index: 200; color: white;
    }
    .menu-btn {
        padding: 15px 50px; margin: 10px; font-size: 20px; cursor: pointer;
        background: #444; color: white; border: 2px solid #666; transition: 0.3s;
    }
    .menu-btn:hover { background: #007bff; border-color: white; }
    /* Add this to your <style> section */
.menu-group-id {
    position: absolute;
    top: 20px;
    font-size: 28px;
    font-weight: bold;
    color: #007bff; /* Matching the title color */
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}
    /* Shop Button Styling */
    .shop-btn {
        background: #444; color: white; border: 2px solid #888; padding: 15px; 
        margin: 10px; cursor: pointer; width: 300px; text-align: left; font-size: 18px;
        transition: 0.2s; border-radius: 5px;
    }
    .shop-btn:hover { background: #555; border-color: #28a745; transform: scale(1.02); }

    #ui-overlay {
        position: absolute; top: 60px; left: 10px; color: white;
        padding: 10px; background: rgba(0, 0, 0, 0.7); border-radius: 8px; z-index: 10;
        display: none; flex-direction: column;
    }
    #shop-button { background: #28a745; color: white; margin-top:10px; cursor: pointer; border:none; padding:8px;}
    #pause-button { background: #dc3545; color: white; margin-top:5px; cursor: pointer; border:none; padding:8px;}

    #game-over-screen, #shop-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.9); color: white; display: none;
        flex-direction: column; justify-content: center; align-items: center; z-index: 100;
    }
</style>
</head>
<body>
    <div id="group-id">GROUP ID: 6710</div>

    <div id="main-menu">
        
        <h1 style="font-size: 60px; margin-bottom: 10px; color: #007bff;">PRIMAL STRIKE</h1>
        <div style="margin-bottom: 30px; text-align: center; color: #ccc; line-height: 1.6;">
            <p><b>WASD</b> to Move | <b>Mouse</b> to Aim | <b>Left Click</b> to Attack</p>
            <p>Defeat enemies to open the portal and upgrade your stats!</p>
        </div>
        <button class="menu-btn" onclick="startGame(false)">PLAY PROTOTYPE</button>
        <button class="menu-btn" onclick="startGame(true)" style="background: #007bff;">PLAY FULL MODE</button>
        <div class="menu-group-id">GROUP ID: 6710</div>
    </div>

    <div id="hp-bar-container">
        <div id="hp-bar-fill"></div>
        <div id="hp-text">HP: 10 / 10</div>
    </div>

    <div id="splash-text" style="position: absolute; top: 70px; left: 50%; transform: translateX(-50%); color: #00ffff; font-size: 32px; font-weight: bold; text-shadow: 2px 2px #000; display: none; z-index: 60;">
        LEVEL COMPLETED - PORTAL OPEN
    </div>

    <div id="ui-overlay">
        <p>MODE: <span id="mode-display">PROTOTYPE</span></p>
        <p>CURRENCY: <span id="currency-display">0</span></p>
        <p>LEVEL: <span id="level-display">1</span></p>
        <p>KILLS: <span id="kill-display">0</span> / <span id="max-kills-display">10</span></p>
        <button id="shop-button" onclick="pauseGame(false)">ðŸ’° SHOP</button>
        <button id="pause-button" onclick="pauseGame(true)">|| PAUSE</button>
    </div>
    
    <div id="shop-screen">
        <h1 id="shop-header">PAUSED</h1>
        <p>Currency: <span id="shop-currency">0</span></p>
        <div id="shop-items"></div>
        <button onclick="resumeGame()" style="padding: 15px 30px; margin-top: 20px; background: green; color: white; border: none; cursor: pointer; width: 300px; border-radius: 5px;">RESUME</button>
        <button onclick="window.location.reload()" style="padding: 10px 20px; margin-top: 10px; background: #555; color: white; border: none; cursor: pointer; width: 300px; border-radius: 5px;">EXIT TO MENU</button>
    </div>

    <div id="nav-arrow" style="position: absolute; top: 50%; left: 50%; width: 70px; height: 10px; display: none; z-index: 20; transform-origin: 35px 5px;">
        <div style="width: 60px; height: 10px; background: yellow; border-radius: 5px;"></div>
        <div style="position: absolute; left: 60px; top: -5px; border-top: 10px solid transparent; border-bottom: 10px solid transparent; border-left: 15px solid yellow;"></div>
    </div>
    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>

        // --- Core Scene Variables ---
        let scene, camera, renderer, clock = new THREE.Clock(); 
        let player, damageCone;
        let ambientParticles = []; 
        let walls = [];
        let enemies = []; 
        let healthKits = []; 
        let door; 
        
        const keys = {};
        let isAttacking = false;
        let isGameOver = false;
        let isShopping = false; 
        let isLevelCleared = false; 
        let isPaused = false; 
        const ATTACK_DURATION = 150; 
        const ATTACK_COOLDOWN = 300; 
        let CONE_RADIUS = 2.5; 
        let CONE_HEIGHT = 3.5; 

        // --- Game State Variables ---
        const MAP_SIZE = 25; 
        const LEVEL_WIDTH = MAP_SIZE * 2; 
        
        let currentLevel = 1;
        let killCount = 0;
        let maxKills = 10; 
        const PLAYER_MAX_HP = 10;
        let ENEMY_DAMAGE = 1; 

        let playerHP = PLAYER_MAX_HP;
        let currency = 0; 
        let isFullMode = false;
        let lastDamageTime = 0;
        const DAMAGE_COOLDOWN = 1.0; 
        let playerSpeed = 0.15; 

        let projectiles = [];
const attackSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3');

        // --- Difficulty Scaling ---
        function getEnemySpeed(level) { return 0.08 + (level * 0.01); }
        function getEnemyHP(level) { return 1 + Math.floor(level / 2); }
        function getEnemyCurrencyDrop(level) { return 1 + Math.floor(level / 5); }
        
        function calculateNextMaxKills() {
            const base = 10; 
            const change = Math.floor(Math.random() * 7) - 3; 
            maxKills = Math.max(5, base + change); 
        }

        // --- Helper Bounding Box for Player Collision (Excluding Cone) ---
        let playerBoundingBox;
        
        // --- UI / Shop Logic ---

        const upgradeCosts = {
            HP: { cost: 10, effect: 3, name: "Max HP +3" },
            DAMAGE_AREA: { cost: 15, effect: 0.5, name: "Damage Area +0.5" },
            SPEED: { cost: 12, effect: 0.02, name: "Movement Speed +0.02" }
        };

        function pauseGame(isTruePause) {
            if (isGameOver) return;
            isPaused = true;
            
            if (isTruePause) {
                isShopping = false; // Pause button sets shopping to false
                document.getElementById('shop-screen').style.display = 'flex';
                showShop();
            } else if (!isTruePause && !isShopping) {
                // If activated by shop button (isTruePause is false)
                isShopping = true;
                document.getElementById('shop-screen').style.display = 'flex';
                showShop();
            }
        }

        function resumeGame() {
            isPaused = false;
            isShopping = false;
            document.getElementById('shop-screen').style.display = 'none';
        }
        
function updateUI() {
    document.getElementById('currency-display').innerText = currency;
    document.getElementById('level-display').innerText = currentLevel;
    document.getElementById('kill-display').innerText = killCount;
    document.getElementById('max-kills-display').innerText = maxKills;

    const hpPercent = (playerHP / PLAYER_MAX_HP) * 100;
    document.getElementById('hp-bar-fill').style.width = hpPercent + "%";
    document.getElementById('hp-text').innerText = `HP: ${Math.ceil(playerHP)} / ${PLAYER_MAX_HP}`;
    
    if (enemies.length === 0 && killCount >= maxKills && !isLevelCleared) {
        // Show Splash Text
        document.getElementById('splash-text').style.display = 'block';
        
        isLevelCleared = true;
        door.userData.isOpen = true;
        door.material.opacity = 0.2; 
        if (isFullMode) door.material.wireframe = false;
    } else if (isLevelCleared === false) {
        document.getElementById('splash-text').style.display = 'none';
    }
}

function startGame(isFull) {
    isFullMode = isFull;
    isPaused = false;
    isGameOver = false; // Reset game over state
    
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('ui-overlay').style.display = 'flex';
    document.getElementById('hp-bar-container').style.display = 'block';
    document.getElementById('mode-display').innerText = isFullMode ? 'FULL' : 'PROTOTYPE';
    
    // Reset player position and stats
    player.position.set(0, 0.75, 0);
    playerHP = PLAYER_MAX_HP;
    currency = 0;
    currentLevel = 1;
    killCount = 0;
    
    calculateNextMaxKills();
    generateLevelSet();
    updateUI();
}

        


function showShop() {
    document.getElementById('shop-currency').innerText = currency;
    const shopItemsDiv = document.getElementById('shop-items');
    shopItemsDiv.innerHTML = '';

    Object.keys(upgradeCosts).forEach(type => {
        const upgrade = upgradeCosts[type];
        const btn = document.createElement('button');
        btn.className = 'shop-btn';
        btn.innerHTML = `<b>${upgrade.name}</b><br>Cost: ${upgrade.cost} Currency`;
        btn.onclick = () => buyUpgrade(type, upgrade.cost, upgrade.effect);
        shopItemsDiv.appendChild(btn);
    });
}        
        function buyUpgrade(type, cost, effect) {
            if (currency < cost) {
                alert("Not enough currency!");
                return;
            }
            
            currency -= cost;
            
            switch (type) {
                case 'HP':
                    playerHP += effect;
                    break;
                case 'DAMAGE_AREA':
                    CONE_HEIGHT += effect;
                    CONE_RADIUS += effect / 2;
                    createDamageCone(); 
                    break;
                case 'SPEED':
                    playerSpeed += effect;
                    break;
            }
            
            showShop(); 
            updateUI();
        }

        // --- Game Over / Damage / Mode Toggle ---

        function takeDamage(amount) {
            if (isGameOver) return;
            const currentTime = clock.getElapsedTime();
            if (currentTime - lastDamageTime < DAMAGE_COOLDOWN) return;

            playerHP -= amount;
            playerHP = Math.max(0, playerHP);
            lastDamageTime = currentTime;
            
            if (playerHP <= 0) { gameOver(); } 
            else {
                player.material.color.setHex(0xff0000);
                setTimeout(() => { player.material.color.setHex(0x00ff00); }, 100);
            }
            updateUI();
        }

        function gameOver() {
            isGameOver = true;
            document.getElementById('final-level').innerText = currentLevel;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        function toggleMode() {
            isFullMode = !isFullMode;
            
            const modeText = isFullMode ? 'FULL' : 'PROTOTYPE';
            document.getElementById('mode-display').innerText = modeText;
            document.getElementById('mode-toggle').innerText = `Switch to ${isFullMode ? 'PROTOTYPE' : 'FULL'} Mode`;
            
            generateLevelSet(); 
            createDamageCone(); 
        }
        
        // --- Input Handler Functions (UNCHANGED) ---

        function onKeyDown(event) { keys[event.key.toLowerCase()] = true; }
        function onKeyUp(event) { keys[event.key.toLowerCase()] = false; }
function onMouseDown(event) {
    // Only attack if left mouse button (0) is pressed and menu is hidden
    if (event.button === 0 && 
        document.getElementById('main-menu').style.display === 'none' && 
        !isGameOver && !isShopping && !isPaused) {
        startAttack();
    }
}
        function onMouseMove(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectionPoint = new THREE.Vector3();

            raycaster.ray.intersectPlane(groundPlane, intersectionPoint);

            if (intersectionPoint) {
                const targetPoint = intersectionPoint.clone();
                targetPoint.y = player.position.y;
                player.lookAt(targetPoint);
            }
        }
        
        // --- Object Creation Functions ---
        
        function getWallMaterial() { return new THREE.MeshBasicMaterial({ color: isFullMode ? 0x666666 : 0x888888, wireframe: !isFullMode }); }
        function getEnemyMaterial() { return new THREE.MeshBasicMaterial({ color: isFullMode ? 0xcc0000 : 0xff0000, wireframe: !isFullMode }); }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(500, 500); 
            const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = Math.PI / 2;
            ground.position.y = 0;
            scene.add(ground);
        }

        function createPlayer() {
            const playerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16);
            const playerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, 0.75, 0); 
            player.userData.radius = 0.5;
            scene.add(player);
            
            player.geometry.computeBoundingBox(); 
            playerBoundingBox = new THREE.Box3().setFromObject(player); 
        }

function createDamageCone() {
    // 1. Safety check
    if (!player) return;

    // 2. Remove old cone if it exists
    if (player.userData.conePivot) {
        player.remove(player.userData.conePivot);
    }
    
    // 3. Create the geometry
    const coneGeometry = new THREE.ConeGeometry(CONE_RADIUS, CONE_HEIGHT, 8);
    const coneMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff4500, transparent: true, opacity: 0.5, wireframe: !isFullMode 
    });
    damageCone = new THREE.Mesh(coneGeometry, coneMaterial);
    
    // 4. Set up the Pivot (This is what rotates)
    const conePivot = new THREE.Object3D();
    conePivot.rotation.y = Math.PI; 
    player.add(conePivot);

    // 5. Position the cone relative to the pivot
    damageCone.rotation.x = Math.PI / 2;
    damageCone.position.z = -CONE_HEIGHT / 2; 
    damageCone.position.y = 0.1;
    
    conePivot.add(damageCone);
    
    // 6. Force visibility to false initially (startAttack will toggle it)
    damageCone.visible = false; 
    
    // 7. Store reference
    player.userData.conePivot = conePivot; 
}
        function createAmbientParticles(count) {
             for (let i = 0; i < count; i++) {
                 const geo = new THREE.TetrahedronGeometry(0.05);
                 const mat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: Math.random() * 0.4 + 0.1 });
                 const particle = new THREE.Mesh(geo, mat);
                 particle.position.set(Math.random() * 40 - 20, Math.random() * 2 + 0.1, Math.random() * 40 - 20);
                 particle.userData.speed = Math.random() * 0.01 + 0.005;
                 ambientParticles.push(particle);
                 scene.add(particle);
             }
         }

         function animateAmbientParticles() {
             const time = clock.getElapsedTime(); 
             ambientParticles.forEach(p => {
                 p.rotation.x += p.userData.speed;
                 p.rotation.y += p.userData.speed / 2;
                 p.position.y = (Math.sin(time + p.position.x * 0.5) * 0.1) + 1;
             });
         }
         
        // *** MODIFIED: Creates the health kit (White box with red cross) ***
        function createHealthKit(x, z) {
            const kitGroup = new THREE.Group();
            
            // 1. White Base Box
            const baseGeo = new THREE.BoxGeometry(1.5, 0.5, 1.5);
            const baseMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const baseBox = new THREE.Mesh(baseGeo, baseMat);
            baseBox.position.set(0, 0.25, 0); // half height
            kitGroup.add(baseBox);

            // 2. Red Plus Sign (Horizontal Bar) - Flat on top of base
            const redMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const horizGeo = new THREE.BoxGeometry(1.6, 0.1, 0.4);
            const horizBar = new THREE.Mesh(horizGeo, redMat);
            horizBar.position.set(0, 0.5 + 0.01, 0); // Position on top of the base box
            kitGroup.add(horizBar);

            // 3. Red Plus Sign (Vertical Bar) - Flat on top of base
            const vertGeo = new THREE.BoxGeometry(0.4, 0.1, 1.6);
            const vertBar = new THREE.Mesh(vertGeo, redMat);
            vertBar.position.set(0, 0.5 + 0.01, 0); // Position on top of the base box
            kitGroup.add(vertBar);

            kitGroup.position.set(x, 0, z); // Group position
            kitGroup.userData.hpRestore = 3; 

            healthKits.push(kitGroup);
            scene.add(kitGroup);
        }


        // --- Level Generation and Management ---

        function clearLevelMeshes() {
            enemies.forEach(mesh => scene.remove(mesh));
            enemies = [];
            ambientParticles.forEach(mesh => scene.remove(mesh));
            ambientParticles = [];
            
            walls.forEach(mesh => scene.remove(mesh));
            walls = [];
            if (door) scene.remove(door);
            door = null;
            
            healthKits.forEach(mesh => scene.remove(mesh));
            healthKits = [];
        }

        function generateLevelSet() {
            const currentOffset = 0;
            const nextLevelOffset = -LEVEL_WIDTH; 
            
            clearLevelMeshes();
            createDamageCone(); 
            
            createProceduralLevel(currentOffset, MAP_SIZE, true);
            createProceduralLevel(nextLevelOffset, MAP_SIZE, false);
            
            createAmbientParticles(50);
            
            // Scatter health kits
            const numHealthKits = 3;
            for(let i = 0; i < numHealthKits; i++) {
                createHealthKit(Math.random() * 40 - 20, Math.random() * 40 - 20); 
            }

            const numEnemiesToSpawn = maxKills; 
            for (let i = 0; i < numEnemiesToSpawn; i++) {
        // 70% chance for basic, 30% for shooter
        if (Math.random() > 0.3) {
            spawnEnemy(currentOffset, 0, 0);
        } else {
            spawnEnemy2(currentOffset, 0, 0);
        }
    }
        }
        
        function createProceduralLevel(xOffset, size, isCurrentLevel) {
            const wallMaterial = getWallMaterial();
            const WALL_HEIGHT = 2;
            
            const boundarySegments = [
                [xOffset, size, size * 2, 1], 
                [xOffset, -size, size * 2, 1], 
                [xOffset + size, 0, 1, size * 2], 
                [xOffset - size, 0, 1, size * 2] 
            ];
            
            boundarySegments.forEach(([x, z, sx, sz], index) => {
                if (isCurrentLevel && index === 3) { // TARGET LEFT WALL
                    addWall(x, z + 7.5, sx, sz - 15, wallMaterial); 
                    addWall(x, z - 7.5, sx, sz - 15, wallMaterial); 
                    
                    if (isCurrentLevel) { 
                        createDoor(x + 0.5, z, xOffset); 
                    }
                } else { 
                    addWall(x, z, sx, sz, wallMaterial); 
                }
            });
            
            const numObstacles = 10 + Math.floor(Math.random() * 5); 
            for (let i = 0; i < numObstacles; i++) {
                const x = Math.random() * (size * 2 - 4) - (size - 2) + xOffset;
                const z = Math.random() * (size * 2 - 4) - (size - 2);
                const isHorizontal = Math.random() > 0.5;
                const sizeX = isHorizontal ? (Math.random() * 5 + 3) : 1;
                const sizeZ = isHorizontal ? 1 : (Math.random() * 5 + 3);
                if (Math.abs(x - xOffset) > 5 || Math.abs(z) > 5) { addWall(x, z, sizeX, sizeZ, wallMaterial); }
            }
        }
        
        function addWall(x, z, sx, sz, material) {
             const WALL_HEIGHT = 2;
             const geo = new THREE.BoxGeometry(sx, WALL_HEIGHT, sz);
             const mesh = new THREE.Mesh(geo, material);
             mesh.position.set(x, WALL_HEIGHT / 2, z);
             walls.push(mesh);
             scene.add(mesh);
        }
        
        function createDoor(x, z, xOffset) {
             const doorMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, transparent: true, opacity: 1, wireframe: !isFullMode
            });
             const doorGeometry = new THREE.BoxGeometry(1, 2, 10); 
             door = new THREE.Mesh(doorGeometry, doorMaterial);
             door.position.set(x, 1, z); 
             door.userData.isOpen = false;
             door.userData.targetX = xOffset + 10;
             scene.add(door);
        }
        
// Standard Melee Enemy
function spawnEnemy(x, y, z) {
    if (isLevelCleared) return;
    const geo = new THREE.BoxGeometry(1, 1, 1);
    const mat = getEnemyMaterial();
    const enemy = new THREE.Mesh(geo, mat);
    
    enemy.position.set(x + Math.random() * 5, 0.5, z + Math.random() * 5);
    enemy.userData = {
        alive: true,
        hp: getEnemyHP(currentLevel),
        speed: getEnemySpeed(currentLevel),
        type: 'basic'
    };
    
    enemies.push(enemy);
    scene.add(enemy);
}

// NEW: Projectile Shooter Enemy
function spawnEnemy2(x, y, z) {
    if (isLevelCleared) return;
    // Octahedron shape to distinguish from basic cubes
    const geo = new THREE.OctahedronGeometry(0.7); 
    const mat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: !isFullMode });
    const enemy = new THREE.Mesh(geo, mat);

    enemy.position.set(x + Math.random() * 5, 0.5, z + Math.random() * 5);
    enemy.userData = {
        alive: true,
        hp: getEnemyHP(currentLevel),
        speed: getEnemySpeed(currentLevel) * 0.4, // Shooters move slower
        type: 'shooter',
        lastShot: 0
    };
    
    enemies.push(enemy);
    scene.add(enemy);

}


function spawnProjectile(startPos, targetPos) {
    const geo = new THREE.SphereGeometry(0.2);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const bullet = new THREE.Mesh(geo, mat);
    bullet.position.copy(startPos);
    
    // Calculate direction towards player
    const dir = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
    bullet.userData.velocity = dir.multiplyScalar(0.2);
    
    projectiles.push(bullet);
    scene.add(bullet);
}

function handleProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.position.add(p.userData.velocity);
        
        // Check collision with player
        const dist = p.position.distanceTo(player.position);
        if (dist < 0.8) {
            takeDamage(1);
            scene.remove(p);
            projectiles.splice(i, 1);
            continue;
        }
        
        // Cleanup if out of bounds
        if (p.position.length() > 100) {
            scene.remove(p);
            projectiles.splice(i, 1);
        }
    }
}

function goToNextLevel() {
    currentLevel++;
    killCount = 0;
    isLevelCleared = false; 
    calculateNextMaxKills(); 
            updateUI();

            const shiftAmount = LEVEL_WIDTH;
            scene.children.forEach(obj => {
                if (obj !== player && obj.position) {
                    obj.position.x += shiftAmount;
                }
            });
            
            player.position.x = MAP_SIZE - 2; 
            player.position.z = 0; 

            generateLevelSet();
        }


        // --- Core Game Logic ---

        function handlePlayerMovement(deltaTime) {
            if (isGameOver || isShopping || isPaused) return; 
            const moveSpeed = playerSpeed; 
            
            if (keys['w']) { player.position.z -= moveSpeed * deltaTime * 60; }
            if (keys['s']) { player.position.z += moveSpeed * deltaTime * 60; }
            if (keys['a']) { player.position.x -= moveSpeed * deltaTime * 60; }
            if (keys['d']) { player.position.x += moveSpeed * deltaTime * 60; }

            checkPlayerWallCollision();
            checkDoorCollision();
            checkHealthKitCollision();
            
            // Update Nav Arrow Rotation
            if (door && door.userData.isOpen) {
                const targetPos = door.position.clone();
                const playerPos = player.position.clone();
                
                const angle = Math.atan2(targetPos.z - playerPos.z, targetPos.x - playerPos.x);
                
                const arrow = document.getElementById('nav-arrow');
                arrow.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;
                arrow.style.display = 'block';
            } else {
                document.getElementById('nav-arrow').style.display = 'none';
            }
        }

        function checkDoorCollision() {
            if (!door || !door.userData.isOpen || isShopping || isPaused) return; 
            
            player.geometry.computeBoundingBox();
            const playerBox = player.geometry.boundingBox.clone().applyMatrix4(player.matrixWorld);
            const doorBox = new THREE.Box3().setFromObject(door);
            
            if (playerBox.intersectsBox(doorBox)) {
                 goToNextLevel();
            }
        }

        function checkHealthKitCollision() {
            if (isGameOver || isShopping || isPaused) return;

            player.geometry.computeBoundingBox();
            const playerBox = player.geometry.boundingBox.clone().applyMatrix4(player.matrixWorld);

            for (let i = healthKits.length - 1; i >= 0; i--) {
                const kit = healthKits[i];
                // Check collision against the group (the box containing the pieces)
                const kitBox = new THREE.Box3().setFromObject(kit);
                
                if (playerBox.intersectsBox(kitBox)) {
                    playerHP = Math.min(PLAYER_MAX_HP, playerHP + kit.userData.hpRestore);
                    
                    scene.remove(kit);
                    healthKits.splice(i, 1);
                    
                    updateUI();
                    
                    player.material.color.setHex(0x008000); 
                    setTimeout(() => { player.material.color.setHex(0x00ff00); }, 100);
                }
            }
        }


        function checkPlayerWallCollision() {
            player.geometry.computeBoundingBox();
            const playerBox = player.geometry.boundingBox.clone().applyMatrix4(player.matrixWorld);
            
            const displacement = 0.05; 

            for (const wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                
                if (playerBox.intersectsBox(wallBox)) {
                    
                    const dx = Math.min(
                        playerBox.max.x - wallBox.min.x,
                        wallBox.max.x - playerBox.min.x
                    );
                    const dz = Math.min(
                        playerBox.max.z - wallBox.min.z,
                        wallBox.max.z - playerBox.min.z
                    );

                    if (dx < dz) {
                        if (playerBox.max.x > wallBox.min.x && playerBox.max.x < wallBox.max.x) {
                            player.position.x -= dx + displacement;
                        } else {
                            player.position.x += dx + displacement;
                        }
                    } else {
                        if (playerBox.max.z > wallBox.min.z && playerBox.max.z < wallBox.max.z) {
                            player.position.z -= dz + displacement;
                        } else {
                            player.position.z += dz + displacement;
                        }
                    }
                    playerBox.copy(player.geometry.boundingBox).applyMatrix4(player.matrixWorld);
                }
            }
        }

        function checkEnemyPlayerCollision() {
            const playerBox = player.geometry.boundingBox.clone().applyMatrix4(player.matrixWorld);

            for (const enemy of enemies) {
                const enemyBox = new THREE.Box3().setFromObject(enemy);
                if (playerBox.intersectsBox(enemyBox)) {
                    takeDamage(ENEMY_DAMAGE);
                }
            }
        }

        function moveEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (!enemy.userData.alive) continue;
                
                const direction = new THREE.Vector3().subVectors(player.position, enemy.position);
                direction.y = 0;
                direction.normalize();

                enemy.position.addScaledVector(direction, enemy.userData.speed * deltaTime * 60);

                const targetPoint = player.position.clone();
                targetPoint.y = enemy.position.y;
                enemy.lookAt(targetPoint);
            }
            checkEnemyPlayerCollision();
        }

        function animateFullModeSlash() {
             const slashGeo = new THREE.PlaneGeometry(CONE_HEIGHT * 2.0, 0.5); 
             const slashMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 });
             const slashMesh = new THREE.Mesh(slashGeo, slashMat);
             
             const conePivot = player.userData.conePivot;
             
             slashMesh.rotation.x = Math.PI / 2;
             slashMesh.rotation.z = Math.PI / 2; 

             slashMesh.position.z = -CONE_HEIGHT / 2.5; 
             slashMesh.position.y = 0.5;

             slashMesh.scale.x = CONE_RADIUS * 2; 

             conePivot.add(slashMesh);

             let opacity = 1.0;
             const fadeInterval = setInterval(() => {
                 opacity -= 0.2;
                 slashMesh.material.opacity = opacity;
                 if (opacity <= 0) {
                     clearInterval(fadeInterval);
                     if(slashMesh.parent) slashMesh.parent.remove(slashMesh);
                 }
             }, ATTACK_DURATION / 6);
        }


function startAttack() {
    if (isAttacking || isGameOver || isShopping || isPaused) return; 
    
    // Play Sound
    attackSound.currentTime = 0;
    attackSound.play();

    isAttacking = true;
    damageCone.visible = true; // Show cone during attack in both modes

    if (isFullMode) animateFullModeSlash();

    const conePivot = player.userData.conePivot;
    const startRotation = -Math.PI / 8; 
    const endRotation = Math.PI / 8; 
    
    const startTime = clock.getElapsedTime(); 

    function animateSwing() {
        const elapsed = clock.getElapsedTime() - startTime;
        const progress = elapsed / (ATTACK_DURATION / 1000);

        if (progress < 1) {
            conePivot.rotation.y = Math.PI + startRotation + (endRotation - startRotation) * progress;
            checkHitsInCone();
            requestAnimationFrame(animateSwing);
        } else {
            damageCone.visible = false; // Hide cone after attack
            setTimeout(() => { isAttacking = false; }, ATTACK_COOLDOWN);
        }
    }
    animateSwing();
}

        function checkHitsInCone() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (!enemy.userData.alive) continue;
                
                const dist = player.position.distanceTo(enemy.position);
                const effectiveAttackRange = CONE_HEIGHT * 0.9; 

                if (dist < effectiveAttackRange) {
                    const playerForward = new THREE.Vector3(0, 0, 1).applyQuaternion(player.quaternion);
                    const enemyDir = new THREE.Vector3().subVectors(enemy.position, player.position).normalize();
                    
                    if (playerForward.dot(enemyDir) > 0.5) { 
                        enemy.userData.hp -= 1; 
                        
                        if (enemy.userData.hp <= 0) {
                            enemy.userData.alive = false;
                            scene.remove(enemy);
                            enemies.splice(i, 1);
                            
                            currency += getEnemyCurrencyDrop(currentLevel);
                            
                            killCount++;
                            updateUI(); 

                        } else {
                             enemy.material.color.setHex(0xffff00);
                             setTimeout(() => { enemy.material.color.setHex(isFullMode ? 0xcc0000 : 0xff0000); }, 100);
                        }
                    }
                }
            }
        }
        
        // --- Utility Functions (UNCHANGED) ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Mobile Button Handlers (UNCHANGED) ---
// Change this section at the end of your script:
document.querySelectorAll('.d-button').forEach(button => {
    if(!button) return; // Add this check
    const key = button.getAttribute('data-key');
    button.addEventListener('touchstart', () => { keys[key] = true; }, false);
    button.addEventListener('touchend', () => { keys[key] = false; }, false);
});

const atkBtn = document.getElementById('attack-button');
if(atkBtn) { // Add this check
    atkBtn.addEventListener('touchstart', startAttack, false);
    atkBtn.addEventListener('mousedown', startAttack, false);
}
        // --- Initialization and Loop ---

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);
    
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 0); 
    camera.rotation.x = -Math.PI / 2; 
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0x404040, 5);
    scene.add(ambientLight);
    
    createGround();
    createPlayer(); // Player must be created here!
    createDamageCone();
    
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('keyup', onKeyUp, false);
    document.addEventListener('mousemove', onMouseMove, false);
    document.addEventListener('mousedown', onMouseDown, false);
    
    // We do NOT call generateLevelSet here anymore
    animate();
}
        
function animate() {
    requestAnimationFrame(animate);
    if (document.getElementById('main-menu').style.display !== 'none') return;
    if (isGameOver || isShopping || isPaused) return; 

    const deltaTime = clock.getDelta();
    const time = clock.getElapsedTime();

    handlePlayerMovement(deltaTime);
    moveEnemies(deltaTime); // This handles movement for all types
    handleProjectiles();     // Process moving bullets
    animateAmbientParticles(); 

    // Shooter-specific Shooting AI
    enemies.forEach(enemy => {
        if (enemy.userData.type === 'shooter' && enemy.userData.alive) {
            const dist = enemy.position.distanceTo(player.position);
            // Shoot if player is within range and cooldown is over
            if (dist < 12 && time - enemy.userData.lastShot > 2.0) {
                spawnProjectile(enemy.position, player.position);
                enemy.userData.lastShot = time;
            }
        }
    });

    camera.position.x = player.position.x;
    camera.position.z = player.position.z;
    renderer.render(scene, camera);
}
        // Run the initialization
        init();
        updateUI(); 
    </script>
</body>
</html>
